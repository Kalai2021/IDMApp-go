# IDM Application - PKCE Login Flow Diagram

## Overview
This diagram shows the complete PKCE (Proof Key for Code Exchange) authentication flow for the IDM application, including both frontend and backend interactions.

## PKCE Login Flow

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend (React)
    participant B as Backend (Go)
    participant DB as Database
    participant L as Logger (Fluentd)

    Note over U,L: PKCE Authentication Flow

    %% Step 1: User initiates login
    U->>F: 1. Click Login
    F->>F: 2. Generate PKCE Code Verifier (random string)
    F->>F: 3. Generate PKCE Code Challenge (SHA256 hash)
    F->>L: 4. Log: Login initiated
    Note right of F: Code Verifier: abc123...<br/>Code Challenge: xyz789...

    %% Step 2: Frontend requests authorization
    F->>B: 5. POST /api/v1/auth/login<br/>{email, password, code_challenge, code_challenge_method}
    B->>L: 6. Log: Login request received
    B->>DB: 7. Validate user credentials
    DB-->>B: 8. User data + salt/hash
    B->>B: 9. Verify password hash
    alt Valid Credentials
        B->>B: 10. Generate authorization code
        B->>DB: 11. Store PKCE data<br/>{code, code_challenge, expires_at}
        B->>L: 12. Log: User authenticated successfully
        B-->>F: 13. 200 OK<br/>{authorization_code, expires_in}
    else Invalid Credentials
        B->>L: 12. Log: Authentication failed
        B-->>F: 13. 401 Unauthorized<br/>{error: "Invalid credentials"}
    end

    %% Step 3: Frontend exchanges code for tokens
    alt Valid Response
        F->>F: 14. Store authorization code
        F->>B: 15. POST /api/v1/auth/token<br/>{authorization_code, code_verifier, grant_type}
        B->>L: 16. Log: Token exchange request
        B->>DB: 17. Retrieve PKCE data by code
        B->>B: 18. Verify code_verifier matches challenge
        B->>B: 19. Check if code is expired
        alt Valid PKCE Exchange
            B->>B: 20. Generate access token & refresh token
            B->>DB: 21. Store tokens<br/>{user_id, access_token, refresh_token, expires_at}
            B->>L: 22. Log: Tokens generated successfully
            B-->>F: 23. 200 OK<br/>{access_token, refresh_token, expires_in}
            F->>F: 24. Store tokens in localStorage
            F->>L: 25. Log: User logged in successfully
            F-->>U: 26. Redirect to Dashboard
        else Invalid PKCE Exchange
            B->>L: 22. Log: PKCE verification failed
            B-->>F: 23. 400 Bad Request<br/>{error: "Invalid code verifier"}
        end
    else Invalid Response
        F-->>U: 14. Show error message
    end

    %% Step 4: Subsequent API calls
    Note over U,L: Authenticated API Calls
    U->>F: 27. Navigate to protected route
    F->>B: 28. GET /api/v1/users<br/>Authorization: Bearer {access_token}
    B->>L: 29. Log: API request with token
    B->>B: 30. Validate JWT token
    alt Valid Token
        B->>DB: 31. Fetch users data
        B->>L: 32. Log: API request successful
        B-->>F: 33. 200 OK<br/>{users: [...]}
        F-->>U: 34. Display users
    else Invalid Token
        B->>L: 32. Log: Token validation failed
        B-->>F: 33. 401 Unauthorized
        F->>F: 34. Clear tokens & redirect to login
    end

    %% Step 5: Token refresh flow
    Note over U,L: Token Refresh (when needed)
    F->>B: 35. POST /api/v1/auth/refresh<br/>{refresh_token}
    B->>L: 36. Log: Token refresh request
    B->>DB: 37. Validate refresh token
    alt Valid Refresh Token
        B->>B: 38. Generate new access token
        B->>DB: 39. Update tokens in database
        B->>L: 40. Log: Token refreshed successfully
        B-->>F: 41. 200 OK<br/>{access_token, expires_in}
        F->>F: 42. Update stored access token
    else Invalid Refresh Token
        B->>L: 40. Log: Refresh token invalid
        B-->>F: 41. 401 Unauthorized
        F->>F: 42. Clear tokens & redirect to login
    end
```

## PKCE Security Benefits

### 1. **Code Verifier Protection**
- **Code Verifier**: Random string generated by client
- **Code Challenge**: SHA256 hash of code verifier
- **Protection**: Prevents authorization code interception attacks

### 2. **Flow Security**
- **Step 1**: Client sends code challenge (not verifier)
- **Step 2**: Server stores code challenge with authorization code
- **Step 3**: Client sends code verifier to exchange for tokens
- **Step 4**: Server verifies code verifier matches stored challenge

### 3. **Token Management**
- **Access Token**: Short-lived (15-60 minutes)
- **Refresh Token**: Long-lived (7-30 days)
- **Automatic Refresh**: Frontend handles token renewal

## Implementation Details

### Frontend (React)
```typescript
// PKCE Code Generation
const generateCodeVerifier = () => {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64URLEncode(array);
};

const generateCodeChallenge = async (verifier: string) => {
  const hash = await crypto.subtle.digest('SHA-256', 
    new TextEncoder().encode(verifier));
  return base64URLEncode(new Uint8Array(hash));
};
```

### Backend (Go)
```go
// PKCE Validation
func validatePKCE(code, codeVerifier string) bool {
    // Retrieve stored code challenge
    storedChallenge := getStoredCodeChallenge(code)
    
    // Generate challenge from verifier
    computedChallenge := generateCodeChallenge(codeVerifier)
    
    // Compare challenges
    return storedChallenge == computedChallenge
}
```

## Error Handling

### Common PKCE Errors
1. **Invalid Code Verifier**: Mismatch with stored challenge
2. **Expired Authorization Code**: Code used after expiration
3. **Missing PKCE Parameters**: Required parameters not provided
4. **Invalid Grant Type**: Incorrect grant_type in token request

### Logging Points
- Login initiation
- Authentication success/failure
- PKCE validation results
- Token generation and refresh
- API request authentication

## Security Considerations

### 1. **Code Verifier Requirements**
- Minimum 43 characters
- Maximum 128 characters
- Use cryptographically secure random generation
- URL-safe base64 encoding

### 2. **Code Challenge Methods**
- **S256**: SHA256 hash (recommended)
- **plain**: No transformation (deprecated)

### 3. **Token Security**
- Store tokens securely (httpOnly cookies recommended)
- Implement token rotation
- Monitor for suspicious activity
- Log all authentication events

### 4. **Rate Limiting**
- Limit login attempts per IP
- Implement exponential backoff
- Monitor for brute force attacks

## Monitoring and Observability

### Key Metrics
- Login success/failure rates
- PKCE validation success rates
- Token refresh frequency
- Authentication latency
- Error rates by type

### Alerts
- High authentication failure rates
- Unusual PKCE validation failures
- Token refresh anomalies
- Geographic login anomalies

This PKCE flow provides robust security for your IDM application while maintaining a smooth user experience. 